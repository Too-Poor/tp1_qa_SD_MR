/**
 * Auteurs : Salif et Soti, Groupe : 02
 * Fichier : ExpressionArithmetique.java
 * Cours   : 420-3A6-MO (TP5, Expressions arithmétiques et Sudoku)
 * Date    : 6 novembre 2019
 */

// Packages.

import java.util.*;

/**
 * La classe ExpressionArithmetique contient tout ce qu'il faut pour créer un objet pour une expression arithmétique et
 * de l'évaluer.
 */

public class ExpressionArithmetique {
	
	// Constante de la classe ExpressionArithmetique.

	public static final int MAX_CAR_EXPRESSION = 80;

	// Variable de classe de type HasMap pour associer priorités aux opérateurs.
	// La clé est l'opérateur et la valeur est la priorité.

	private static HashMap<Character, Integer> priorite = new HashMap<>();

	// Champs d'instance de la classe ExpressionArithmetique.
	
	private char[] tabInfixe = new char[MAX_CAR_EXPRESSION];    // Le tableau de caractères pour l'expression infixe.
	
	private char[] tabPostfixe = new char[MAX_CAR_EXPRESSION];  // Le tableau de caractères pour l'expression postfixe.

	private int resultatFinal;                                  // Le résultat final de l'expression.

	/**
	 * Le constructeur ExpressionArithmetique() permet de construire un objet expression arithmétique. Il transforme
	 * l'expression infixe en postfixe et ensuite il évalue l'expression transformée.
	 * 
	 * @param expression
	 *            L'expression arithmétique.
	 */

	public ExpressionArithmetique( String expression ) {
		
		this.tabInfixe = expression.toCharArray();
		this.transformerInfixeEnPostfixe();
		this.evaluerExpression();
	}

	/**
	 * La méthode statique de classe initialiserPrioriteOperateurs() permet d'ajouter dans la variable privée statique
	 * de classe de type HashMap les opérateurs avec leur priorité.
	 */

	public static void initialiserPrioriteOperateurs() {

		priorite.put( '=' , 0 );
		priorite.put( '(' , 1 );
		priorite.put( '+' , 2 );
		priorite.put( '-' , 2 );
		priorite.put( '*' , 3 );
		priorite.put( '/' , 3 );
		
	}

	/**
	 * L'accesseur getTabInfixe() permet d'obtenir la valeur du champ privé tabInfixe.
	 * 
	 * @return Le tableau infixe sous forme de String.
	 */

	public String getTabInfixe() {
		return new String( this.tabInfixe );
	}

	/**
	 * L'accesseur getTabPostfixe() permet d'obtenir la valeur du champ privé tabPostfixe.
	 * 
	 * @return Le tableau postfixe sous forme de String. Les caractères nuls sont remplacés par des espaces pour
	 *         améliorer l'affichage.
	 */

	public String getTabPostfixe() {
		return new String( this.tabPostfixe ).replace( '\0', ' ' );
	}

	/**
	 * L'accesseur getResultatFinal() permet d'obtenir la valeur du champ privé resultatFinal.
	 * 
	 * @return Le resultat final de l'expression arithmétique.
	 */

	public int getResultatFinal() {
		return this.resultatFinal;
	}

	/**
	 * La méthode privée transformerInfixeEnPostfixe() permet de transformer l'expression infixe en postfixe.
	 */

	private void transformerInfixeEnPostfixe() {
		
		int indPostfixe = 0;
		char carInfixe;
		char carPile;
		
		Pile<Character> pileTransformation = new Pile<Character>();
		
		pileTransformation.empiler( '=' );
		
		for ( int i = 0; i < tabInfixe.length; i++ ) {
			
			carInfixe = tabInfixe[i];
			
			if ( Character.isDigit( carInfixe ) ) {
				// TODO Utiliser des constantes pour les opérateurs.
				tabPostfixe[indPostfixe] = carInfixe;
				++indPostfixe;
			} else if (carInfixe == '(') {
				pileTransformation.empiler( '(' );
			} else if (carInfixe == ')') {
				
				carPile = pileTransformation.depiler();
				
				while ( carPile != '(' ) {
					tabPostfixe[indPostfixe] = carPile;
					++indPostfixe;
					carPile = pileTransformation.depiler();
				}
				
			} else {
				carPile = pileTransformation.depiler();
				
				while ( priorite.get( carPile ) >= priorite.get(carInfixe) ) {
					tabPostfixe[indPostfixe] = carPile;
					++indPostfixe;
					carPile = pileTransformation.depiler();
				}
				
				pileTransformation.empiler( carPile );
				pileTransformation.empiler( carInfixe );
			}
		}
		
		carPile = pileTransformation.depiler();
		
		while ( carPile != '=' ) {
			tabPostfixe[indPostfixe] = carPile;
			++indPostfixe;
			carPile = pileTransformation.depiler();
		}
		
		tabPostfix[indPostfixe] = carPile;
	}
	

	/**
	 * La méthode privée evaluerExpression() permet d'évaluer l'expression transformée en postfixe.
	 */

	private void evaluerExpression() {
	
		
		/**
		 * TODO (À COMPLÉTER). Voir page 5 de l'énoncé du TP5.
		 */

	}

	/**
	 * La méthode privée evaluerOperateur() permet d'évaluer le résultat de valeur opérateur valeur.
	 * 
	 * @param val2Pile
	 *            Une valeur.
	 * @param operateur
	 *            Un opérateur.
	 * @param val1Pile
	 *            Une autre valeur.
	 * @return Le résultat du calcul.
	 */

	private int evaluerOperateur( int val2Pile, char operateur, int val1Pile ) {
		int resultat = 0;


		/**
		 * TODO (À COMPLÉTER). Voir page 5 de l'énoncé du TP5.
		 */

		return resultat;
	}

	/**
	 * La méthode publique afficherExpression() permet d'afficher l'expression arithmétique et son résultat.
	 */

	public void afficherExpression() {

		final String TITRE = "\nExpression arithmétique : ";

		
		/**
		 * TODO (À COMPLÉTER). Voir page 6 de l'énoncé du TP5.
		 */
		
	}
}
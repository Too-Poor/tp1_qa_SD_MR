/**
 * Auteurs : Salif et Soti, Groupe : 02
 * Fichier : Sudoku.java
 * Cours   : 420-3A6-MO (TP5, Expressions arithmétiques et Sudoku)
 * Date    : 6 novembre 2019
 */

// Packages.

import java.util.*;

/**
 * La classe Sudoku contient les informations et les méthodes qui permettent de construire et de résoudre une grille de
 * sudoku.
 */

public class Sudoku {
	
	// Constantes de la classe Sudoku.

	private static final String TITRE_INITIAL = "\nGrille initiale";

	private static final String TITRE_FINAL = "\nGrille finale";

	// Champs d'instance privés de la classe Sudoku.

	private int[][] grille;  // La grille de sudoku.

	private int dimGrille;  // Dimension de la grille.
	private int dimBloc;    // Dimension d'un bloc de la grille.

	private boolean[][] presentLigne;    // Tableau pour vérifier si un chiffre est présent sur une ligne.
	private boolean[][] presentColonne;  // Tableau pour vérifier si un chiffre est présent sur une colonne.
	private boolean[][] presentBloc;     // Tableau pour vérifier si un chiffre est présent sur un bloc.

	private LinkedList<PositionGrilleSudoku> listePositions;  // La liste des positions vides à remplir.

	/**
	 * Constructeur qui permet de construire une grille de sudoku avec le tableau reçu en paramètre.
	 * 
	 * Il permet d'initialiser la grille, la dimension de la grille et la dimension d'un bloc de la grille.
	 * 
	 * @param grille
	 *            Le tableau à deux dimensions de nombres entiers contenant les données de la grille initiale de
	 *            sudoku.
	 */

	public Sudoku( int[][] grille ) {

		this.grille = grille;
		this.dimGrille = grille[0].length; //TODO
		this.dimBloc = (int) Math.sqrt( this.dimGrille );
		
	}

	/**
	 * Méthode qui permet de trouver et d'afficher la solution de la grille de sudoku. Elle permet d'afficher la grille
	 * initiale, d'initialiser les tableaux des présences des chiffres, d'initialiser la liste des positions à remplir,
	 * de lancer la résolution de la grille et d'afficher la grille finale.
	 */

	public void trouverAfficherSolution() {

		this.afficherGrille( TITRE_INITIAL );
		this.initialiserTableauxPresences();
		this.creerListePositions();
		
		ListIterator<PositionGrilleSudoku> iterateurPosition = listePositions.listIterator();
		
		this.resoudreSudoku( iterateurPosition );
		
		listePositions.clear();
		
		this.afficherGrille( TITRE_FINAL );
	}

	/**
	 * Méthode qui permet de déterminer à quel bloc appartient une position de la grille.
	 * 
	 * @param ligne
	 *            La coordonnée ligne de la position.
	 * @param colonne
	 *            La coordonnée colonne de la position.
	 * 
	 * @return Le numéro du bloc de la position.
	 */

	private int noBloc( int ligne, int colonne ) {

		// Voir les explications à la page 12 de l'énoncé du TP5 pour comprendre l'utilité de cette méthode.
		
		return this.dimBloc * ( ligne / this.dimBloc ) + ( colonne / this.dimBloc );
	}

	/**
	 * Méthode qui permet de marquer la présence d'un chiffre sur une ligne, sur une colonne et sur un bloc.
	 * 
	 * @param ligne
	 *            La ligne.
	 * @param colonne
	 *            La colonne.
	 * @param chiffre
	 *            Le chiffre.
	 * @param presence
	 *            true pour présent et false pour pas présent.
	 */

	private void marquerPresenceChiffre( int ligne, int colonne, int chiffre, boolean presence ) {

		// Voir les explications aux pages 13 à 15 de l'énoncé du TP5 pour comprendre l'utilité de cette méthode.

		presentLigne[ligne][chiffre] = presence;
		presentColonne[colonne][chiffre] = presence;
		presentBloc[this.noBloc( ligne, colonne )][chiffre] = presence;
	}

	/**
	 * Méthode qui permet d'initialiser les tableaux des présences des chiffres. Les chiffres qui ne sont pas présents
	 * sont marqués par le booléen false. Les chiffres déjà présents sont marqués par le booléen true. Cette façon de
	 * faire permet de rendre l'algorithme plus optimal. Un accès direct permettra de vérifier la présence d'un
	 * chiffre.
	 */

	private void initialiserTableauxPresences() {

		// Les tableaux seront déjà initialisés à false après la création de ceux-ci.

		presentLigne = new boolean[this.dimGrille][this.dimGrille];
		presentColonne = new boolean[this.dimGrille][this.dimGrille];
		presentBloc = new boolean[this.dimGrille][this.dimGrille];

		// Marquer les chiffres présents.

		
		
	}

	/**
	 * Méthode qui vérifie la présence d'un chiffre sur une ligne, sur une colonne et sur un bloc.
	 * 
	 * @param ligne
	 *            La ligne.
	 * @param colonne
	 *            La colonne.
	 * @param chiffre
	 *            Le chiffre.
	 * 
	 * @return true si le chiffre est présent et false dans la cas contraire.
	 */

	private boolean chiffrePresent( int ligne, int colonne, int chiffre ) {

		boolean present = true;

		
		/**
		 * TODO (À COMPLÉTER). Voir page 15 de l'énoncé du TP5.
		 */
		
		return present;
	}

	/**
	 * Méthode qui calcule le nombre de valeurs possibles pour une position à remplir.
	 * 
	 * @param ligne
	 *            La coordonnée ligne de la position.
	 * @param colonne
	 *            La coordonnée colonne de la position.
	 * 
	 * @return Le nombre de valeurs possibles pour la position.
	 */

	private int calculerNbValeursPossibles( int ligne, int colonne ) {

		int nbValeurs = 0;


		/**
		 * TODO (À COMPLÉTER). Voir page 15 de l'énoncé du TP5.
		 */

		return nbValeurs;
	}

	/**
	 * Méthode qui permet de créer la liste des positions à remplir. La liste sera ensuite triée en ordre des nb. de
	 * valeurs possibles. L'exploration des possibilités sera minimisée et l'algorithme sera alors plus optimal.
	 */

	private void creerListePositions() {

		
		/**
		 * TODO (À COMPLÉTER). Voir page 16 de l'énoncé du TP5.
		 */
		
	}

	/**
	 * Méthode qui permet d'afficher une ligne selon la dimension de la grille.
	 */

	private void afficherLigne() {

		for ( int i = 1; i <= this.dimGrille; i++ ) {
			System.out.print( "--" );
		}

		System.out.println( "-" );
	}

	/**
	 * Méthode qui permet d'afficher la grille de sudoku.
	 * 
	 * @param titre
	 *            Le titre à afficher avant la grille.
	 */

	private void afficherGrille( String titre ) {

		System.out.println( titre );

		afficherLigne();

		for ( int li = 0; li < this.dimGrille; ++li ) {

			System.out.print( "|" );

			for ( int col = 0; col < this.dimGrille; ++col ) {

				System.out.print( ( grille[li][col] == 0 ? " " : grille[li][col] )
						+ ( ( col + 1 ) % this.dimBloc != 0 ? " " : "|" ) );
			}

			System.out.println();

			if ( ( li + 1 ) % this.dimBloc == 0 ) {

				afficherLigne();
			}
		}
	}

	/**
	 * Méthode récursive qui permet de résoudre une grille de sudoku. Les positions à remplir de la grille sont
	 * remplies au fur et à mesure. Une vérification constante est faite pour s'assurer que la grille reste toujours
	 * valide. Si une impasse survient, il ne sert à rien de continuer et un retour en arrière permet d'éviter de
	 * continuer une exploration inutile (backtracking).
	 * 
	 * @param iterateur
	 *            L'itérateur de la liste de la position courante à remplir.
	 * 
	 * @return true si la grille est valide et false dans le cas contraire.
	 */

	private boolean resoudreSudoku( ListIterator<PositionGrilleSudoku> iterateur ) {

		boolean estValide = false;

		
		/**
		 * TODO (À COMPLÉTER). Voir pages 16 et 17 de l'énoncé du TP5.
		 */
		
		return estValide;
	}
}